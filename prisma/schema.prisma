// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ==================== ADMIN & AUTH ====================

model AdminUser {
  id                 String  @id @default(cuid())
  email              String  @unique
  username           String?
  password           String
  firstname          String?
  lastname           String?
  preferedLanguage   String?
  blocked            Boolean @default(false)
  isActive           Boolean @default(false)
  registrationToken  String?
  resetPasswordToken String?

  roles     AdminRole[] @relation("AdminUserRoles")
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt

  @@map("admin_users")
}

model AdminRole {
  id          String  @id @default(cuid())
  code        String  @unique
  name        String
  description String?

  users       AdminUser[]       @relation("AdminUserRoles")
  permissions AdminPermission[]
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt

  @@map("admin_roles")
}

model AdminPermission {
  id               String  @id @default(cuid())
  action           String
  subject          String?
  actionParameters Json    @default("{}")
  conditions       Json    @default("[]")
  properties       Json    @default("{}")

  roleId String
  role   AdminRole @relation(fields: [roleId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("admin_permissions")
}

// ==================== UNIFIED RBAC ====================

/// Fine-grained permission definition. Reusable across roles, tokens, and individual user grants.
model Permission {
  id               String   @id @default(cuid())
  action           String   // e.g., "orders.create", "bookings.read", "inventory.transfer"
  subject          String?  // optional object context e.g., "orders", "bookings"
  description      String?
  actionParameters Json     @default("{}")  // complex rule parameters
  conditions       Json     @default("[]")  // additional constraints
  properties       Json     @default("{}")  // extra metadata

  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  rolePermissions   RolePermission[]
  userPermissions   UserPermission[]  // direct user overrides
  tokenPermissions  TokenPermission[]

  @@unique([action, subject])
  @@index([action])
  @@index([subject])
  @@map("permissions")
}

/// Role definition: a named group of permissions. Can be admin-scoped or department-scoped.
model Role {
  id          String   @id @default(cuid())
  code        String   @unique
  name        String
  description String?
  type        String   @default("standard")  // admin, employee, manager, custom
  isActive    Boolean  @default(true)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  rolePermissions  RolePermission[]
  userRoles        UserRole[]

  @@index([code, type])
  @@index([isActive])
  @@map("roles")
}

/// Explicit join: which permissions are granted by a role.
model RolePermission {
  id           String     @id @default(cuid())

  roleId       String
  role         Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)

  permissionId String
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  createdAt    DateTime   @default(now())

  @@unique([roleId, permissionId])
  @@index([roleId])
  @@index([permissionId])
  @@map("role_permissions")
}

/// Explicit join: which roles are assigned to a user. Supports department scoping and audit trail.
model UserRole {
  id           String    @id @default(cuid())

  userId       String    // works with AdminUser.id or PluginUsersPermissionsUser.id
  userType     String    // "admin" | "employee" | "other"

  roleId       String
  role         Role      @relation(fields: [roleId], references: [id], onDelete: Cascade)

  /// Optional: scope this role assignment to a specific department
  departmentId String?
  department   Department? @relation(fields: [departmentId], references: [id], onDelete: SetNull)

  /// Audit trail
  grantedAt    DateTime  @default(now())
  grantedBy    String?   // admin user who granted the role (optional)
  revokedAt    DateTime?
  revokedBy    String?

  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@unique([userId, userType, roleId, departmentId])
  @@index([userId, userType])
  @@index([roleId])
  @@index([departmentId])
  @@map("user_roles")
}

/// Direct permission overrides for individual users (bypasses role).
model UserPermission {
  id           String     @id @default(cuid())

  userId       String     // admin or employee user ID
  userType     String     // "admin" | "employee"

  permissionId String
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  /// Optional: scope this permission to a department
  departmentId String?
  department   Department? @relation(fields: [departmentId], references: [id], onDelete: SetNull)

  grantedAt    DateTime   @default(now())
  grantedBy    String?

  @@unique([userId, userType, permissionId, departmentId])
  @@index([userId, userType])
  @@index([permissionId])
  @@map("user_permissions")
}

/// Token-based permissions: map API/Transfer tokens to fine-grained permissions.
model TokenPermission {
  id           String     @id @default(cuid())

  tokenId      String     // ApiToken.id or TransferToken.id
  tokenType    String     // "api" | "transfer"

  permissionId String
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  createdAt    DateTime   @default(now())

  @@unique([tokenId, tokenType, permissionId])
  @@index([tokenId, tokenType])
  @@map("token_permissions")
}

model ApiToken {
  id          String    @id @default(cuid())
  name        String
  description String    @default("")
  accessKey   String    @unique
  type        String    @default("read-only") // read-only, full-access, custom
  expiresAt   DateTime?
  lastUsedAt  DateTime?
  lifespan    BigInt?

  permissions ApiTokenPermission[]
  createdAt   DateTime             @default(now())
  updatedAt   DateTime             @updatedAt

  @@map("api_tokens")
}

model ApiTokenPermission {
  id     String @id @default(cuid())
  action String

  tokenId String
  token   ApiToken @relation(fields: [tokenId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("api_token_permissions")
}

model TransferToken {
  id          String    @id @default(cuid())
  name        String
  description String    @default("")
  accessKey   String    @unique
  expiresAt   DateTime?
  lastUsedAt  DateTime?
  lifespan    BigInt?

  permissions TransferTokenPermission[]
  createdAt   DateTime                  @default(now())
  updatedAt   DateTime                  @updatedAt

  @@map("transfer_tokens")
}

model TransferTokenPermission {
  id     String @id @default(cuid())
  action String

  tokenId String
  token   TransferToken @relation(fields: [tokenId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("transfer_token_permissions")
}

// ==================== HOTEL MANAGEMENT ====================

model Room {
  id          String  @id @default(cuid())
  name        String
  description String?
  roomNumber  String  @unique
  status      String  @default("available") // available, occupied, maintenance
  price       Int
  capacity    Int

  amenities Amenity[]
  beds      Bed[]
  bookings  Booking[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("rooms")
}

model Amenity {
  id          String  @id @default(cuid())
  name        String
  description String?
  icon        String?

  rooms     Room[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("amenities")
}

model Bed {
  id      String @id @default(cuid())
  type    String
  bedSize String
  size    Int

  roomId String
  room   Room   @relation(fields: [roomId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("beds")
}

model FloorPlan {
  id            String  @id @default(cuid())
  floorNumber   Int
  numberOfRooms Int
  description   String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("floor_plans")
}

// ==================== CUSTOMERS & BOOKINGS ====================

model Customer {
  id          String  @id @default(cuid())
  firstName   String
  lastName    String
  email       String  @unique
  phone       String
  nationality String?
  street      String?
  city        String?
  state       String?
  zip         Int?

  bookings         Booking[]
  games            Game[]
  paymentDetails   PaymentDetail[]
  gymMemberships   GymMembership[]
  sportMemberships SportMembership[]
  orders           Order[]
  orderHeaders     OrderHeader[]
  gameSessions     GameSession[]
  serviceUsageSessions  ServiceUsageSession[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("customers")
}

model Booking {
  id         String   @id @default(cuid())
  bookingId  String   @unique
  customerId String
  customer   Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  roomId String
  room   Room   @relation(fields: [roomId], references: [id])

  checkin     DateTime
  checkout    DateTime
  timeIn      String?
  timeOut     String?
  nights      Int
  guests      Int
  isShortRest Boolean  @default(false)

  totalPrice    Int
  bookingStatus String @default("pending")

  paymentId String?
  payment   Payment? @relation(fields: [paymentId], references: [id])

  restaurantId String?
  restaurant   Restaurant? @relation(fields: [restaurantId], references: [id])

  barAndClubId String?
  barAndClub   BarAndClub? @relation(fields: [barAndClubId], references: [id])

  bookingItems  BookingItem[]
  drinks        Drink[]
  foodItems     FoodItem[]
  hotelServices HotelService[]
  productCounts ProductCount[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("bookings")
}

model BookingItem {
  id         String @id @default(cuid())
  name       String
  quantity   Int
  amountPaid Int
  status     String @default("pending") // pending, confirmed, in_progress, completed, cancelled

  bookingId String
  booking   Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  orderId String?
  order   Order?  @relation(fields: [orderId], references: [id])

  barAndClubId String?
  barAndClub   BarAndClub? @relation(fields: [barAndClubId], references: [id])

  drinkTypeId String?
  drinkType   DrinkType? @relation(fields: [drinkTypeId], references: [id])

  foodTypeId String?
  foodType   FoodType? @relation(fields: [foodTypeId], references: [id])

  menuCategoryId String?
  menuCategory   MenuCategory? @relation(fields: [menuCategoryId], references: [id])

  paymentTypeId String?
  paymentType   PaymentType? @relation(fields: [paymentTypeId], references: [id])

  drinks           Drink[]
  foodItems        FoodItem[]
  games            Game[]
  gymMemberships   GymMembership[]
  sportMemberships SportMembership[]
  hotelServices    HotelService[]
  productCounts    ProductCount[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("booking_items")
}

model CheckIn {
  id           String    @id @default(cuid())
  checkInTime  DateTime
  checkOutTime DateTime?

  employeeSummaryId String?
  employeeSummary   EmployeeSummary? @relation(fields: [employeeSummaryId], references: [id])

  gymMembershipId String?
  gymMembership   GymMembership? @relation(fields: [gymMembershipId], references: [id])

  sportMembershipId String?
  sportMembership   SportMembership? @relation(fields: [sportMembershipId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("check_ins")
}

// ==================== RESTAURANT & BAR ====================

model Restaurant {
  id          String  @id @default(cuid())
  name        String
  location    String
  description String?
  openTime    String?
  closeTime   String?

  activeOrders    Int @default(0)
  completedOrders Int @default(0)
  amountSold      Int @default(0)

  foodItems      FoodItem[]
  menuCategories MenuCategory[]
  bookings       Booking[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("restaurants")
}

model BarAndClub {
  id          String  @id @default(cuid())
  name        String
  location    String
  description String?
  openTime    String?
  closeTime   String?
  happyHours  String?
  entryFees   Int?

  activeOrders    Int @default(0)
  completedOrders Int @default(0)
  amountSold      Int @default(0)
  debt            Int @default(0)

  drinks       Drink[]
  bookings     Booking[]
  bookingItems BookingItem[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("bar_and_clubs")
}

// ==================== INVENTORY MANAGEMENT ====================

model InventoryType {
  id          String  @id @default(cuid())
  typeName    String  @unique
  description String?
  category    String? // e.g., "drinks", "supplies", "equipment", "linens"

  inventoryItems InventoryItem[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("inventory_types")
}

model InventoryItem {
  id            String    @id @default(cuid())
  name          String
  description   String?
  sku           String    @unique
  category      String
  itemType      String? // drink, supply, equipment, linens, etc.
  quantity      Int       @default(0)
  reorderLevel  Int       @default(10)
  maxQuantity   Int?
  unitPrice     Decimal   @db.Decimal(10, 2)
  location      String? // storage location
  supplier      String?
  lastRestocked DateTime?
  expiry        DateTime?

  isActive      Boolean   @default(true)
  deletedAt     DateTime?

  inventoryTypeId String
  inventoryType   InventoryType @relation(fields: [inventoryTypeId], references: [id], onDelete: Cascade)

  movements    InventoryMovement[]
  reservations InventoryReservation[]

  // per-department inventory balances
  departmentInventories DepartmentInventory[]
  
  // Can be used as an extra item (with inventory tracking)
  usedAsExtras Extra[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("inventory_items")
}

model InventoryMovement {
  id           String  @id @default(cuid())
  movementType String // "in", "out", "adjustment", "loss"
  quantity     Int
  reason       String?
  reference    String? // booking ID, order ID, etc.

  inventoryItemId String
  inventoryItem   InventoryItem @relation(fields: [inventoryItemId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("inventory_movements")
}

model DepartmentInventory {
  id String @id @default(cuid())

  departmentId String
  department   Department @relation(fields: [departmentId], references: [id], onDelete: Cascade)

  // Optional: if this inventory is scoped to a section
  sectionId String?
  section   DepartmentSection? @relation(fields: [sectionId], references: [id], onDelete: Cascade)

  inventoryItemId String
  inventoryItem   InventoryItem @relation(fields: [inventoryItemId], references: [id], onDelete: Cascade)

  quantity Int @default(0)
  reserved Int @default(0)
  unitPrice Decimal? @db.Decimal(10, 2)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([departmentId, sectionId, inventoryItemId])
  @@index([departmentId])
  @@index([sectionId])
  @@index([inventoryItemId])
  @@map("department_inventories")
}

// ==================== FOOD & DRINKS ====================

model FoodType {
  id          String  @id @default(cuid())
  typeName    String  @unique
  description String?

  foodItems    FoodItem[]
  bookingItems BookingItem[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("food_types")
}

model FoodItem {
  id           String  @id @default(cuid())
  name         String
  description  String?
  image        String?
  price        Decimal @db.Decimal(10, 2)
  availability Boolean @default(true)

  foodTypeId String
  foodType   FoodType @relation(fields: [foodTypeId], references: [id], onDelete: Cascade)

  menuCategoryId String
  menuCategory   MenuCategory @relation(fields: [menuCategoryId], references: [id], onDelete: Cascade)

  restaurantId String?
  restaurant   Restaurant? @relation(fields: [restaurantId], references: [id])

  bookingId String?
  booking   Booking? @relation(fields: [bookingId], references: [id])

  bookingItems  BookingItem[]
  productCounts ProductCount[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("food_items")
}

model MenuCategory {
  id           String  @id @default(cuid())
  categoryName String
  description  String?

  foodItems    FoodItem[]
  bookingItems BookingItem[]
  restaurant   Restaurant?   @relation(fields: [restaurantId], references: [id])
  restaurantId String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("menu_categories")
}

model DrinkType {
  id          String  @id @default(cuid())
  typeName    String  @unique
  description String?

  drinks       Drink[]
  bookingItems BookingItem[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("drink_types")
}

model Drink {
  id              String  @id @default(cuid())
  name            String
  description     String?
  image           String?
  price           Int
  type            String?
  availability    Boolean @default(true)
  quantity        Int     @default(0)
  barStock        Int     @default(0)
  restaurantStock Int     @default(0)
  sold            Int     @default(0)
  supplied        Int     @default(0)
  threshold       Int     @default(10)

  drinkTypeId String
  drinkType   DrinkType @relation(fields: [drinkTypeId], references: [id], onDelete: Cascade)

  barAndClubId String?
  barAndClub   BarAndClub? @relation(fields: [barAndClubId], references: [id])

  bookingId String?
  booking   Booking? @relation(fields: [bookingId], references: [id])

  bookingItems  BookingItem[]
  productCounts ProductCount[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("drinks")
}

// ==================== ORDERS & PAYMENTS ====================

model Order {
  id         String   @id @default(cuid())
  customerId String
  customer   Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  paymentTypeId String
  paymentType   PaymentType @relation(fields: [paymentTypeId], references: [id])

  paymentId String?
  payment   Payment? @relation(fields: [paymentId], references: [id])

  orderHeaderId String?
  orderHeader   OrderHeader? @relation(fields: [orderHeaderId], references: [id])

  total       Int
  orderStatus String @default("Active")

  bookingItems BookingItem[]
  serviceUsageSession ServiceUsageSession?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("orders")
}

model Payment {
  id            String @id @default(cuid())
  transactionID String @unique
  paymentMethod String
  paymentStatus String @default("pending") // pending, completed, failed
  totalPrice    Int

  paymentDetailId String?
  paymentDetails  PaymentDetail? @relation(fields: [paymentDetailId], references: [id])

  bookings Booking[]
  orders   Order[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("payments")
}

model PaymentType {
  id          String  @id @default(cuid())
  type        String  @unique // cash, card, bank_transfer, mobile_payment
  description String?

  bookingItems   BookingItem[]
  expenses       Expense[]
  gymMemberships GymMembership[]
  orders         Order[]
  orderPayments  OrderPayment[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("payment_types")
}

model PaymentDetail {
  id          String  @id @default(cuid())
  paymentID   String  @unique
  bankName    String?
  bankAccount BigInt?

  customerId String
  customer   Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  payments Payment[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("payment_details")
}

// ==================== ENHANCED ORDER SYSTEM ====================

model Department {
  id          String  @id @default(cuid())
  code        String  @unique
  name        String
  description String?
  slug        String? @unique
  type        String? @default("general") // restaurants, bars, gyms, games, etc.
  icon        String? // optional icon name or asset path
  image       String? // optional hero/thumbnail image
  referenceType String? // optional reference: Restaurant, BarAndClub, GymAndSport
  referenceId   String? // optional id of referenced entity
  metadata    Json?   @default("{}")
  isActive    Boolean @default(true)

  orderDepartments OrderDepartment[]
  terminals Terminal[]

  // sections under this department
  sections DepartmentSection[]

  // transfers where this department is the source
  transfersFrom DepartmentTransfer[] @relation("DepartmentTransferFrom")
  // transfers where this department is the destination
  transfersTo DepartmentTransfer[] @relation("DepartmentTransferTo")

  // per-department inventory records
  departmentInventories DepartmentInventory[]

  // per-department extras records
  departmentExtras DepartmentExtra[]
  extras Extra[]

  // Games types managed by this department
  gameTypes GameType[]
  
  // Services managed by this department
  serviceInventory ServiceInventory[]

  // Units (rooms/suites/apartments) managed by this department
  units Unit[]

  // RBAC: Role assignments scoped to this department
  userRoles       UserRole[]
  userPermissions UserPermission[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("departments")
}

model DepartmentSection {
  id           String    @id @default(cuid())
  name         String
  slug         String?   @unique

  departmentId String
  department   Department @relation(fields: [departmentId], references: [id], onDelete: Cascade)

  // per-section inventory records
  inventories DepartmentInventory[]
  
  // per-section extras records
  departmentExtras DepartmentExtra[]
  
  // order lines routed to this section
  orderLines  OrderLine[]
  
  // extras available for this section
  extras      Extra[]
  
  // game sessions in this section (games departments only)
  gameSessions GameSession[]
  
  // services available in this section
  serviceInventory ServiceInventory[]

  metadata     Json?     @default("{}")
  isActive     Boolean   @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([departmentId])
  @@map("department_sections")
}

// Service inventory - flexible pricing model for games, swimming, activities, etc.
// Can be priced per count (per game, per person) or per time unit (per hour, per minute)
model ServiceInventory {
  id              String   @id @default(cuid())
  name            String   // e.g., "Snooker Game", "Swimming", "Gym Pass"
  description     String?
  serviceType     String   // e.g., "game", "activity", "facility"
  
  // Pricing
  pricingModel    String   @default("per_count")  // "per_count" or "per_time"
  pricePerCount   Decimal? @db.Decimal(10, 2)    // Price per unit (game, person, etc.)
  pricePerMinute  Decimal? @db.Decimal(10, 4)    // Price per minute (calculated to hourly in UI)
  
  // Association
  sectionId       String?
  section         DepartmentSection? @relation(fields: [sectionId], references: [id], onDelete: Cascade)
  
  // Link to department if not section-specific
  departmentId    String?
  department      Department? @relation(fields: [departmentId], references: [id], onDelete: Cascade)

  // Service sessions track usage
  sessions        ServiceUsageSession[]
  
  // Game sessions linked to this service for pricing
  gameSessions    GameSession[]
  
  isActive        Boolean  @default(true)
  metadata        Json?    @default("{}")
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@index([sectionId])
  @@index([departmentId])
  @@map("service_inventory")
}

// Service usage session - tracks a customer using a service (games, swimming, gym, etc.)
model ServiceUsageSession {
  id            String   @id @default(cuid())
  
  serviceId     String
  service       ServiceInventory  @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  
  customerId    String
  customer      Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  
  // Usage tracking
  countUsed     Int      @default(0)      // For per_count pricing (e.g., game count, items used)
  minutesUsed   Int      @default(0)      // For per_time pricing
  
  // Calculated amount
  totalAmount   Decimal  @db.Decimal(10, 2) @default(0)
  
  status        String   @default("active")  // active, paused, completed, checked_out
  
  // Links to order system
  orderId       String?  @unique
  order         Order?   @relation(fields: [orderId], references: [id], onDelete: SetNull)
  
  startedAt     DateTime @default(now())
  pausedAt      DateTime?
  endedAt       DateTime?
  checkedOutAt  DateTime?
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@index([customerId])
  @@index([serviceId])
  @@index([status])
  @@map("service_usage_sessions")
}

// POS Terminals (point-of-sale devices / logical terminals)
model Terminal {
  id           String    @id @default(cuid())
  name         String
  slug         String    @unique

  // optional relation to Department (if a terminal is bound to a department)
  departmentId String?
  department   Department? @relation(fields: [departmentId], references: [id], onDelete: SetNull)

  status   String  @default("offline") // online, offline, maintenance
  metadata Json?   @default("{}")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("terminals")
  @@index([slug])
}

model DiscountRule {
  id                  String    @id @default(cuid())
  code                String    @unique
  name                String
  description         String?
  type                String    @default("percentage") // percentage, fixed, tiered
  // VALUE STORAGE FORMAT (expanded minor units for consistency):
  // - Percentage: 20 means 20% (applied to subtotal)
  // - Fixed: 2000000 means $20.00 (stored as 100x cents for unit consistency)
  // All values use same unit expansion to avoid conversion logic
  value               Decimal   @db.Decimal(15, 2) 
  maxUsagePerCustomer Int?
  maxTotalUsage       Int?
  currentUsage        Int       @default(0)
  minOrderAmount      Int? // minimum order total to apply (in expanded minor units)
  applicableDepts     String    @default("[]") // JSON array of department codes (empty = all depts)
  applicableSections  String    @default("[]") // JSON array of section IDs (empty = all sections within applicable depts)
  isActive            Boolean   @default(true)
  startDate           DateTime?
  endDate             DateTime?
  currency            String    @default("USD") // Currency for fixed discounts

  orderDiscounts OrderDiscount[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("discount_rules")
}

model OrderHeader {
  id          String   @id @default(cuid())
  orderNumber String   @unique
  customerId  String
  customer    Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  departmentCode String? // Primary department (can span multiple)
  status         String  @default("pending") // pending, processing, fulfilled, completed, cancelled
  paymentStatus  String  @default("unpaid") // unpaid, paid, partial, refunded
  
  subtotal      Int @default(0)
  discountTotal Int @default(0)
  tax           Int @default(0)
  total         Int @default(0)

  notes String?
  createdBy String? // User ID who created this order (for audit trail)

  lines        OrderLine[]
  departments  OrderDepartment[]
  discounts    OrderDiscount[]
  payments     OrderPayment[]
  fulfillments OrderFulfillment[]
  extras       OrderExtra[] @relation("OrderExtras")
  reservations InventoryReservation[]
  legacyOrders Order[]
  gameSession  GameSession?  // Link to game session if this order is for a game

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([customerId])
  @@index([createdBy])
  @@index([status])
  @@index([paymentStatus])
  @@index([createdAt])
  @@map("order_headers")
}

model OrderLine {
  id         String @id @default(cuid())
  lineNumber Int

  orderHeaderId String
  orderHeader   OrderHeader @relation(fields: [orderHeaderId], references: [id], onDelete: Cascade)

  departmentCode String
  
  departmentSectionId String?
  departmentSection   DepartmentSection? @relation(fields: [departmentSectionId], references: [id], onDelete: SetNull)
  
  productId      String // Could be FoodItem, Drink, HotelService, etc.
  productType    String // food, drink, service, membership, game, etc.
  productName    String

  quantity     Int
  unitPrice    Int
  unitDiscount Int @default(0)
  lineTotal    Int // quantity * unitPrice - unitDiscount

  status String @default("pending") // pending, processing, fulfilled, cancelled

  fulfillments OrderFulfillment[]
  extras       OrderExtra[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([orderHeaderId])
  @@index([departmentCode])
  @@index([departmentSectionId])
  @@map("order_lines")
}

model OrderDepartment {
  id String @id @default(cuid())

  orderHeaderId String
  orderHeader   OrderHeader @relation(fields: [orderHeaderId], references: [id], onDelete: Cascade)

  departmentId String
  department   Department @relation(fields: [departmentId], references: [id])

  status          String  @default("pending") // pending, processing, fulfilled, completed
  departmentNotes String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([orderHeaderId, departmentId])
  @@index([departmentId])
  @@map("order_departments")
}

model OrderDiscount {
  id String @id @default(cuid())

  orderHeaderId String
  orderHeader   OrderHeader @relation(fields: [orderHeaderId], references: [id], onDelete: Cascade)

  discountRuleId String?
  discountRule   DiscountRule? @relation(fields: [discountRuleId], references: [id])

  discountType   String // percentage, fixed, employee, bulk
  discountCode   String? // Promo code or employee ID
  description    String?
  discountAmount Int
  appliedAt      DateTime @default(now())

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([orderHeaderId])
  @@map("order_discounts")
}

/// Audit log for admin actions (create/update/delete)
model AdminAuditLog {
  id         String   @id @default(cuid())
  actorId    String?
  actorType  String?  // admin | employee | system
  action     String   // create, update, delete
  subject    String?  // e.g., departments, inventory_items
  subjectId  String?  // id of the subject
  details    Json?    @default("{}")

  createdAt DateTime @default(now())

  @@index([actorId])
  @@map("admin_audit_logs")
}

model OrderPayment {
  id String @id @default(cuid())

  orderHeaderId String
  orderHeader   OrderHeader @relation(fields: [orderHeaderId], references: [id], onDelete: Cascade)

  amount               Int
  paymentMethod        String // cash, card, bank_transfer, mobile_payment, etc.
  paymentStatus        String  @default("pending") // pending, completed, failed, refunded
  transactionReference String?

  paymentTypeId String?
  paymentType   PaymentType? @relation(fields: [paymentTypeId], references: [id])

  processedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([orderHeaderId])
  @@index([paymentStatus])
  @@map("order_payments")
}

model OrderFulfillment {
  id String @id @default(cuid())

  orderHeaderId String
  orderHeader   OrderHeader @relation(fields: [orderHeaderId], references: [id], onDelete: Cascade)

  orderLineId String?
  orderLine   OrderLine? @relation(fields: [orderLineId], references: [id], onDelete: SetNull)

  status            String // pending, in_progress, fulfilled, cancelled
  fulfilledQuantity Int    @default(0)

  fulfilledAt DateTime?
  notes       String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([orderHeaderId])
  @@index([status])
  @@map("order_fulfillments")
}

// ==================== EXTRAS (RESTAURANT TERMINALS) ====================

/// Extra items are supplementary items with units for restaurant terminals
/// Examples: side dishes, sauces, extra portions, toppings, etc.
model Extra {
  id           String  @id @default(cuid())
  name         String  // e.g., "Extra Sauce", "Extra Portion", "Topping"
  description  String?
  unit         String  // e.g., "portion", "container", "piece", "pump"
  price        Int     // Price in cents
  isActive     Boolean @default(true)

  // Link to department (parent level)
  departmentId String?
  department   Department? @relation(fields: [departmentId], references: [id], onDelete: Cascade)

  // Link to section where this extra is available (optional - for section-specific extras)
  departmentSectionId String?
  departmentSection   DepartmentSection? @relation(fields: [departmentSectionId], references: [id], onDelete: Cascade)

  // Hybrid approach - can link to inventory item
  // If productId is set, this extra tracks inventory
  productId    String?
  product      InventoryItem? @relation(fields: [productId], references: [id], onDelete: SetNull)
  
  // If true, adding this extra deducts from inventory
  // If false, no inventory impact (standalone extra like sauce)
  trackInventory Boolean @default(false)

  // Reverse relation to order extras
  orderExtras  OrderExtra[]

  // Department-level extra tracking
  departmentExtras DepartmentExtra[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([departmentId])
  @@index([departmentSectionId])
  @@index([productId])
  @@index([isActive])
  @@map("extras")
}

/// Department-level extras management (similar to DepartmentInventory)
model DepartmentExtra {
  id String @id @default(cuid())

  departmentId String
  department   Department @relation(fields: [departmentId], references: [id], onDelete: Cascade)

  // Optional: if this extra is scoped to a section
  sectionId String?
  section   DepartmentSection? @relation(fields: [sectionId], references: [id], onDelete: Cascade)

  extraId String
  extra   Extra @relation(fields: [extraId], references: [id], onDelete: Cascade)

  quantity Int @default(0)
  reserved Int @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([departmentId, sectionId, extraId])
  @@index([departmentId])
  @@index([sectionId])
  @@index([extraId])
  @@map("department_extras")
}

/// Order extras: extras added to specific order lines
model OrderExtra {
  id String @id @default(cuid())

  orderHeaderId String
  orderHeader   OrderHeader @relation("OrderExtras", fields: [orderHeaderId], references: [id], onDelete: Cascade)

  orderLineId String?
  orderLine   OrderLine? @relation(fields: [orderLineId], references: [id], onDelete: SetNull)

  extraId String
  extra   Extra @relation(fields: [extraId], references: [id], onDelete: Restrict)

  quantity     Int
  unitPrice    Int // Price at time of order (in cents)
  lineTotal    Int // quantity * unitPrice (in cents)

  status String @default("pending") // pending, processing, fulfilled, cancelled

  notes String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([orderHeaderId])
  @@index([orderLineId])
  @@index([extraId])
  @@index([status])
  @@map("order_extras")
}

model InventoryReservation {
  id String @id @default(cuid())

  inventoryItemId String
  inventoryItem   InventoryItem @relation(fields: [inventoryItemId], references: [id], onDelete: Cascade)

  orderHeaderId String
  orderHeader   OrderHeader? @relation(fields: [orderHeaderId], references: [id], onDelete: Cascade)

  quantity Int
  status   String @default("reserved") // reserved, confirmed, released, consumed

  reservedAt  DateTime  @default(now())
  confirmedAt DateTime?
  releasedAt  DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([inventoryItemId])
  @@index([orderHeaderId])
  @@map("inventory_reservations")
}

// ==================== DEPARTMENT STOCK TRANSFERS ====================

model DepartmentTransfer {
  id String @id @default(cuid())

  fromDepartmentId String
  fromDepartment   Department @relation("DepartmentTransferFrom", fields: [fromDepartmentId], references: [id], onDelete: Cascade)

  toDepartmentId String
  toDepartment   Department @relation("DepartmentTransferTo", fields: [toDepartmentId], references: [id], onDelete: Cascade)

  status String @default("pending") // pending, approved, completed, cancelled
  notes  String?

  createdBy String?

  items DepartmentTransferItem[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([fromDepartmentId])
  @@index([toDepartmentId])
  @@map("department_transfers")
}

model DepartmentTransferItem {
  id String @id @default(cuid())

  transferId String
  transfer   DepartmentTransfer @relation(fields: [transferId], references: [id], onDelete: Cascade)

  productType String // e.g., 'drink', 'inventoryItem'
  productId   String
  quantity    Int

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([transferId])
  @@map("department_transfer_items")
}

// ==================== GAMES & ENTERTAINMENT ====================

model Game {
  id         String @id @default(cuid())
  count      Int
  amountPaid Int
  amountOwed Int
  gameStatus String

  customerId String
  customer   Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  userId String?
  user   PluginUsersPermissionsUser? @relation(fields: [userId], references: [id])

  bookingItems  BookingItem[]
  productCounts ProductCount[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("games")
}

// ==================== GYM & SPORTS ====================

model GymAndSport {
  id          String  @id @default(cuid())
  name        String
  description String?
  openTime    String?
  closeTime   String?

  sessions         GymAndSportSession[]
  memberships      GymMembership[]
  sportMemberships SportMembership[]
  membershipPlans  MembershipPlan[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("gym_and_sports")
}

model GymAndSportSession {
  id          String   @id @default(cuid())
  sessionName String
  sessionTime DateTime
  sessionFee  Int

  gymAndSports GymAndSport[]
  schedules    Schedule[]
  users        PluginUsersPermissionsUser[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("gym_and_sport_sessions")
}

model GymMembership {
  id               String   @id @default(cuid())
  joinedDate       DateTime
  expiryDate       DateTime
  emergencyContact String?
  isActive         Boolean  @default(true)
  profilePhoto     String?

  customerId String
  customer   Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  gymAndSports  GymAndSport[]
  paymentType   PaymentType?  @relation(fields: [paymentTypeId], references: [id])
  paymentTypeId String?

  membershipPlans MembershipPlan[]
  checkIns        CheckIn[]
  bookingItems    BookingItem[]
  productCounts   ProductCount[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("gym_memberships")
}

model SportMembership {
  id               String   @id @default(cuid())
  joinedDate       DateTime
  expiryDate       DateTime
  emergencyContact String?
  isActive         Boolean  @default(true)

  customerId String
  customer   Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  gymAndSports  GymAndSport[]
  checkIns      CheckIn[]
  bookingItems  BookingItem[]
  productCounts ProductCount[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("sport_memberships")
}

model MembershipPlan {
  id                  String   @id @default(cuid())
  name                String
  description         String?
  price               Int
  durationMonths      Int
  maxCheckinsPerMonth Int?
  discountAmount      Int?
  accessToClasses     Boolean?
  isActive            Boolean  @default(true)

  gymAndSports   GymAndSport[]
  gymMemberships GymMembership[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("membership_plans")
}

// ==================== EMPLOYEE & MANAGEMENT ====================

model PluginUsersPermissionsUser {
  id        String  @id @default(cuid())
  username  String  @unique
  email     String  @unique
  password  String
  firstname String?
  lastname  String?
  blocked   Boolean @default(false)

  employeeOrders  EmployeeOrder[]
  employeeRecords EmployeeRecord[]
  employeeSummary EmployeeSummary?
  employmentData  EmploymentData? @relation("employmentData")
  expenses        Expense[]
  games           Game[]
  sessions        GymAndSportSession[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("users_permissions_users")
}

model EmployeeOrder {
  id             String   @id @default(cuid())
  dateIssued     DateTime
  total          Int
  discountAmount Int
  amountPaid     Int

  userId String
  user   PluginUsersPermissionsUser @relation(fields: [userId], references: [id], onDelete: Cascade)

  hotelServiceId String?
  hotelService   HotelService? @relation(fields: [hotelServiceId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("employee_orders")
}

model EmployeeRecord {
  id            String   @id @default(cuid())
  date          DateTime
  debts         Int
  fines         Int
  shortage      Int
  salaryAdvance Int
  description   String?

  userId String
  user   PluginUsersPermissionsUser @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("employee_records")
}

model EmployeeSummary {
  id                   String    @id @default(cuid())
  position             String?
  employmentDate       DateTime?
  salary               Int
  debtShortage         Decimal   @db.Decimal(10, 2)
  finesDebits          Decimal   @db.Decimal(10, 2)
  orderDiscountTotal   Decimal   @db.Decimal(10, 2)
  salaryAdvanced       Decimal   @db.Decimal(10, 2)
  salaryAdvancedStatus String    @default("pending") // pending, approved, rejected, settled

  userId String                     @unique
  user   PluginUsersPermissionsUser @relation(fields: [userId], references: [id], onDelete: Cascade)

  checkIns CheckIn[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("employee_summaries")
}

// ==================== EMPLOYMENT MANAGEMENT ====================

model EmploymentData {
  id                    String    @id @default(cuid())
  employmentDate        DateTime  // Date employee started
  position              String    // Job position/title
  department            String?   // Department assigned
  salary                Decimal   @db.Decimal(10, 2) // Monthly/base salary
  salaryType            String    @default("monthly") // monthly, hourly, annual
  salaryFrequency       String    @default("monthly") // payment frequency: monthly, bi-weekly, weekly
  employmentStatus      String    @default("active") // active, inactive, on_leave, terminated
  contractType          String?   // permanent, temporary, contract
  reportsTo             String?   // Manager/supervisor ID
  
  // Termination data
  terminationDate       DateTime?
  terminationReason     String?
  terminationNotes      String?
  
  // Deductions & debts tracking
  totalDebts            Decimal   @db.Decimal(10, 2) @default(0)
  totalCharges          Decimal   @db.Decimal(10, 2) @default(0)

  userId String                     @unique
  user   PluginUsersPermissionsUser @relation("employmentData", fields: [userId], references: [id], onDelete: Cascade)

  leaves    EmployeeLeave[]
  charges   EmployeeCharge[]
  termination EmployeeTermination?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([employmentStatus])
  @@index([department, employmentStatus])
  @@map("employment_data")
}

model EmployeeLeave {
  id              String    @id @default(cuid())
  leaveType       String    // sick, vacation, personal, unpaid, etc
  startDate       DateTime
  endDate         DateTime
  numberOfDays    Int
  reason          String?
  status          String    @default("pending") // pending, approved, rejected, cancelled
  approvedBy      String?   // Admin/manager ID
  approvalDate    DateTime?
  notes           String?

  employmentDataId String
  employmentData   EmploymentData @relation(fields: [employmentDataId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([employmentDataId, status])
  @@index([startDate, endDate])
  @@map("employee_leaves")
}

model EmployeeCharge {
  id              String    @id @default(cuid())
  chargeType      String    // debt, fine, shortage, advance, loan, etc
  amount          Decimal   @db.Decimal(10, 2)
  description     String?
  reason          String?
  date            DateTime
  dueDate         DateTime?
  status          String    @default("pending") // pending, paid, partially_paid, waived, cancelled
  paidAmount      Decimal   @db.Decimal(10, 2) @default(0)
  paymentDate     DateTime?
  paymentMethod   String?
  notes           String?

  employmentDataId String
  employmentData   EmploymentData @relation(fields: [employmentDataId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([employmentDataId, status])
  @@index([date])
  @@map("employee_charges")
}

model EmployeeTermination {
  id              String    @id @default(cuid())
  terminationDate DateTime
  reason          String    // resignation, dismissal, retirement, layoff, etc
  details         String?
  finalSettlement Decimal   @db.Decimal(10, 2) // Final amount owed/paid
  settlementStatus String  @default("pending") // pending, completed, disputed
  settlementDate  DateTime?
  notes           String?

  employmentDataId String          @unique
  employmentData   EmploymentData  @relation(fields: [employmentDataId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("employee_terminations")
}

/// Track salary/payment history for auditing and reporting
model SalaryPayment {
  id              String    @id @default(cuid())
  userId          String
  paymentDate     DateTime
  grossSalary     Decimal   @db.Decimal(10, 2)
  deductions      Decimal   @db.Decimal(10, 2) @default(0)
  netSalary       Decimal   @db.Decimal(10, 2)
  paymentMethod   String?
  status          String    @default("completed") // pending, completed, failed
  notes           String?
  salaryDueDate   DateTime?  // When salary is due (calculated from employment date + frequency)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId, paymentDate])
  @@index([salaryDueDate])
  @@map("salary_payments")
}

// ==================== PROJECTS & EXPENSES ====================

model Project {
  id          String   @id @default(cuid())
  name        String
  description String?
  startDate   DateTime
  endDate     DateTime
  budget      Int

  expenses Expense[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("projects")
}

model Expense {
  id       String   @id @default(cuid())
  name     String
  date     DateTime
  amount   Int
  receipts String?

  paymentTypeId String
  paymentType   PaymentType @relation(fields: [paymentTypeId], references: [id])

  userId String
  user   PluginUsersPermissionsUser @relation(fields: [userId], references: [id], onDelete: Cascade)

  projects Project[]
  vendors  Vendor[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("expenses")
}

model Vendor {
  id          String  @id @default(cuid())
  name        String
  address     String?
  email       String?
  phone       String?
  description String?

  expenses Expense[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("vendors")
}

// ==================== UTILITIES & MISCELLANEOUS ====================

model HotelService {
  id                 String  @id @default(cuid())
  name               String
  serviceDescription String?
  price              Int

  bookingId String?
  booking   Booking? @relation(fields: [bookingId], references: [id])

  bookingItems   BookingItem[]
  employeeOrders EmployeeOrder[]
  productCounts  ProductCount[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("hotel_services")
}

model ProductCount {
  id           String @id @default(cuid())
  name         String
  productCount Int
  totalAmount  Int

  bookingId String?
  booking   Booking? @relation(fields: [bookingId], references: [id])

  drinkId String?
  drink   Drink?  @relation(fields: [drinkId], references: [id])

  foodItemId String?
  foodItem   FoodItem? @relation(fields: [foodItemId], references: [id])

  gameId String?
  game   Game?   @relation(fields: [gameId], references: [id])

  hotelServiceId String?
  hotelService   HotelService? @relation(fields: [hotelServiceId], references: [id])

  gymMembershipId String?
  gymMembership   GymMembership? @relation(fields: [gymMembershipId], references: [id])

  sportMembershipId String?
  sportMembership   SportMembership? @relation(fields: [sportMembershipId], references: [id])

  bookingItemId String?
  bookingItem   BookingItem? @relation(fields: [bookingItemId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("product_counts")
}

model Schedule {
  id          String   @id @default(cuid())
  sessionId   String
  sessionDate DateTime

  sessions GymAndSportSession? @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("schedules")
}

model PromoCoupon {
  id                 String    @id @default(cuid())
  couponCode         String    @unique
  description        String?
  discountPercentage Int?
  maxUsage           Int?
  currentUsage       Int       @default(0)
  expiryDate         DateTime?
  isActive           Boolean   @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("promo_coupons")
}

model JobApplication {
  id            String    @id @default(cuid())
  fullName      String
  email         String
  phone         String
  dob           DateTime?
  gender        String?
  position      String
  otherPosition String?
  address       String?
  skills        String?
  resume        String?
  coverLetter   String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("job_applications")
}

model Article {
  id          String  @id @default(cuid())
  title       String
  slug        String  @unique
  description String?
  cover       String?
  blocks      Json?

  authorId String
  author   Author @relation(fields: [authorId], references: [id], onDelete: Cascade)

  categoryId String
  category   Category @relation(fields: [categoryId], references: [id])

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  publishedAt DateTime?

  @@map("articles")
}

model Author {
  id     String  @id @default(cuid())
  name   String
  email  String?
  avatar String?

  articles Article[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("authors")
}

model Category {
  id          String  @id @default(cuid())
  name        String
  slug        String  @unique
  description String?

  articles Article[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("categories")
}

model Slider {
  id       String  @id @default(cuid())
  title    String
  image    String?
  link     String?
  order    Int     @default(0)
  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("sliders")
}

model Carousel {
  id      String  @id @default(cuid())
  title   String
  sliders String? // JSON array of slider references

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("carousels")
}

model About {
  id     String @id @default(cuid())
  title  String
  blocks Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("abouts")
}

model Service {
  id          String  @id @default(cuid())
  title       String
  description String?
  icon        String?
  blocks      Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("services")
}

model Global {
  id              String  @id @default(cuid())
  siteName        String
  siteDescription String
  favicon         String?
  isVatActive     Boolean @default(false)
  defaultSeo      Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("globals")
}

model OrganisationInfo {
  id        String  @id @default(cuid())
  name      String
  address   String?
  email     String?
  phone     String?
  website   String?
  logoDark  String?
  logoLight String?
  facebook  String?
  instagram String?
  twitter   String?
  youTube   String?
  // Organisation currency (ISO 4217) - used as the base currency for prices
  currency   String  @default("USD")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("organisation_infos")
}

/// Persisted exchange rates (admin-managed or imported from external APIs)
model ExchangeRate {
  id           String   @id @default(cuid())
  fromCurrency String
  toCurrency   String
  rate         Decimal  @db.Decimal(24, 12)
  source       String?  // e.g., 'manual', 'ECB', 'exchangerapi'
  updatedBy    String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([fromCurrency, toCurrency])
  @@map("exchange_rates")
}

model SpecialInfo {
  id       String  @id @default(cuid())
  title    String
  content  String?
  type     String? // notice, warning, info, etc
  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("special_infos")
}

/// Tax configuration for orders
model TaxSettings {
  id              String  @id @default(cuid())
  enabled         Boolean @default(true) // Enable/disable tax globally
  taxRate         Float   @default(10) // Tax rate as percentage (e.g., 10 for 10%)
  appliedToSubtotal Boolean @default(true) // If true, tax = (subtotal - discounts) * taxRate / 100
  
  updatedBy       String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@map("tax_settings")
}

// ==================== GAMES SECTION ====================

/// Game types/definitions (e.g., Billiards, Table Tennis, Air Hockey)
/// Scoped to a specific Games department
model GameType {
  id            String   @id @default(cuid())
  name          String
  description   String?
  pricePerGame  Decimal  @db.Decimal(10, 2) // Price per game
  isActive      Boolean  @default(true)
  
  departmentId  String
  department    Department @relation(fields: [departmentId], references: [id], onDelete: Cascade)
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  gameSessions  GameSession[]

  @@unique([departmentId, name])
  @@index([departmentId])
  @@index([isActive])
  @@map("game_types")
}

/// Game session - tracks a customer playing games in a specific section
/// Links to Customer, DepartmentSection (game location), and GameType (for pricing)
/// Integrates with existing Order system for checkout/payment
model GameSession {
  id            String   @id @default(cuid())
  
  customerId    String
  customer      Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  
  sectionId     String
  section       DepartmentSection @relation(fields: [sectionId], references: [id], onDelete: Cascade)
  
  serviceId     String?  // Link to ServiceInventory for pricing
  service       ServiceInventory? @relation(fields: [serviceId], references: [id], onDelete: SetNull)
  
  gameTypeId    String?
  gameType      GameType? @relation(fields: [gameTypeId], references: [id], onDelete: Restrict)
  
  gameCount     Int      @default(1) // Number of games played in this session
  status        String   @default("active") // active, completed, checked_out
  
  totalAmount   Decimal  @db.Decimal(10, 2) @default(0) // Calculated: gameCount * gameType.pricePerGame or service pricing
  
  orderHeaderId String?  @unique  // Links to OrderHeader when checked out (one-to-one)
  orderHeader   OrderHeader? @relation(fields: [orderHeaderId], references: [id], onDelete: SetNull)
  
  startedAt     DateTime @default(now())
  endedAt       DateTime?
  checkedOutAt  DateTime?
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([customerId])
  @@index([sectionId])
  @@index([status])
  @@index([startedAt])
  @@map("game_sessions")
}

// ==================== ROOMS, RESERVATIONS & LODGING ====================

// Enum for unit kind
enum UnitKind {
  ROOM
  SUITE
  APARTMENT
}

// Unit status: derived from reservations, cleaning, maintenance state
enum UnitStatus {
  AVAILABLE        // No reservation, not cleaning, not in maintenance
  OCCUPIED         // Active reservation checked-in
  CLEANING         // Cleaning task in progress
  MAINTENANCE      // Maintenance work order in progress
  BLOCKED          // Out-of-service
}

// Reservation status
enum ReservationStatus {
  PENDING          // Created, awaiting payment
  CONFIRMED        // Paid/secured
  CHECKED_IN       // Guest in unit
  CHECKED_OUT      // Guest departed, cleaning pending
  COMPLETED        // Cleaning done, reservation closed
  CANCELLED        // Guest cancelled
}

/// Room Type (e.g., Deluxe Room, Standard Suite)
model RoomType {
  id              String   @id @default(cuid())
  code            String   @unique
  name            String
  description     String?
  capacity        Int      // Max guests
  bedSize         String?  // e.g., "Queen", "Twin", "King", "Double"
  roomSizeM2      Int?     // Room size in square meters
  amenities       Json?    // { "wifi": true, "ac": true, ... }
  basePriceCents  Int      // Base price in cents
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  units           Unit[]
  pricingOverrides PricingOverride[]

  @@index([code])
  @@map("room_types")
}

/// Unit (individual room, suite, apartment instance)
model Unit {
  id              String   @id @default(cuid())
  roomNumber      String   @unique
  unitKind        UnitKind @default(ROOM)
  roomTypeId      String
  roomType        RoomType @relation(fields: [roomTypeId], references: [id], onDelete: Restrict)
  departmentId    String?  // Optional: link to housekeeping/front-desk dept
  department      Department? @relation(fields: [departmentId], references: [id], onDelete: SetNull)
  status          UnitStatus @default(AVAILABLE)
  statusUpdatedAt DateTime @default(now())
  notes           String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  reservations    Reservation[]
  cleaningTasks   CleaningTask[]
  maintenanceReqs MaintenanceRequest[]
  statusHistory   UnitStatusHistory[]

  @@index([roomTypeId])
  @@index([departmentId])
  @@index([status])
  @@index([roomNumber])
  @@map("units")
}

/// Guest information
model Guest {
  id              String   @id @default(cuid())
  firstName       String
  lastName        String
  email           String   @unique
  phone           String?
  idNumber        String?  // Passport, license, etc.
  country         String?
  notes           String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  reservations    Reservation[]

  @@index([email])
  @@map("guests")
}

/// Reservation booking
model Reservation {
  id              String   @id @default(cuid())
  confirmationNo  String   @unique @default(cuid()) // Short code for guest reference
  unitId          String
  unit            Unit     @relation(fields: [unitId], references: [id], onDelete: Restrict)
  guestId         String
  guest           Guest    @relation(fields: [guestId], references: [id], onDelete: Restrict)
  checkInDate     DateTime // Normalized to start-of-day UTC
  checkOutDate    DateTime // Normalized to start-of-day UTC
  status          ReservationStatus @default(PENDING)
  totalPriceCents Int      // Total cost in cents (base price * nights + extras)
  paidCents       Int      @default(0)
  currency        String   @default("USD")
  source          String?  // web, app, phone, walk-in
  notes           String?
  idempotencyKey  String?  @unique // For preventing double-booking
  createdBy       String?  // User ID who created reservation
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  checkInTime     DateTime? // Actual check-in
  checkOutTime    DateTime? // Actual check-out

  @@index([unitId])
  @@index([guestId])
  @@index([checkInDate, checkOutDate])
  @@index([status])
  @@unique([unitId, checkInDate, checkOutDate]) // Prevent overlaps
  @@map("reservations")
}

/// Pricing overrides (seasonal rates, special events)
model PricingOverride {
  id              String   @id @default(cuid())
  roomTypeId      String
  roomType        RoomType @relation(fields: [roomTypeId], references: [id], onDelete: Cascade)
  startDate       DateTime // Normalized to start-of-day UTC
  endDate         DateTime // Normalized to start-of-day UTC
  pricePerNightCents Int
  reason          String?  // "Peak Season", "Event", etc.
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([roomTypeId, startDate, endDate])
  @@map("pricing_overrides")
}

// ==================== CLEANING MANAGEMENT ====================

// Cleaning task status
enum CleaningTaskStatus {
  PENDING         // Assigned, waiting to start
  IN_PROGRESS     // Cleaner started work
  COMPLETED       // Work done, awaiting inspection
  INSPECTED       // QA pass
  REJECTED        // Failed QA, needs re-work
  CANCELLED       // Task cancelled
}

// Cleaning priority
enum CleaningPriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

/// Cleaning task (triggered by check-out or manual request)
model CleaningTask {
  id              String   @id @default(cuid())
  taskNumber      String   @unique @default(cuid())
  unitId          String
  unit            Unit     @relation(fields: [unitId], references: [id], onDelete: Restrict)
  priority        CleaningPriority @default(NORMAL)
  status          CleaningTaskStatus @default(PENDING)
  taskType        String   // "turnover", "deep_clean", "maintenance_clean", "touch_up"
  assignedToId    String?  // Cleaner/Housekeeper user ID
  startedAt       DateTime?
  completedAt     DateTime?
  inspectedAt     DateTime?
  inspectedById   String?  // QA inspector user ID
  notes           String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  logs            CleaningLog[]

  @@index([unitId])
  @@index([status])
  @@index([assignedToId])
  @@index([createdAt])
  @@map("cleaning_tasks")
}

/// Cleaning log: checklist items, notes, photos
model CleaningLog {
  id              String   @id @default(cuid())
  taskId          String
  task            CleaningTask @relation(fields: [taskId], references: [id], onDelete: Cascade)
  loggedById      String   // Cleaner or QA user ID
  itemType        String   // "bed_linens", "bathroom", "floor", "windows", etc.
  status          String   // "complete", "incomplete", "issue_found"
  notes           String?
  photoUrl        String?  // Optional: cleanliness/damage photo
  createdAt       DateTime @default(now())

  @@index([taskId])
  @@map("cleaning_logs")
}

// ==================== MAINTENANCE MANAGEMENT ====================

// Maintenance request status
enum MaintenanceStatus {
  OPEN            // Created, not yet assigned
  ASSIGNED        // Assigned to technician
  IN_PROGRESS     // Technician working
  ON_HOLD         // Waiting for parts or approval
  COMPLETED       // Work done, awaiting sign-off
  VERIFIED        // Manager verified fix
  CLOSED          // Archived
  CANCELLED       // Not proceeding
}

// Maintenance priority
enum MaintenancePriority {
  LOW             // Minor, non-urgent (leaky faucet)
  NORMAL          // Standard repair (AC not working)
  HIGH            // Affects safety/comfort (no heat)
  CRITICAL        // Emergency (electrical, flooding)
}

/// Maintenance request (work order)
model MaintenanceRequest {
  id              String   @id @default(cuid())
  workOrderNo     String   @unique @default(cuid())
  unitId          String
  unit            Unit     @relation(fields: [unitId], references: [id], onDelete: Restrict)
  requestedBy     String   // User ID (guest, staff, inspection)
  requestedAt     DateTime @default(now())
  category        String   // "electrical", "plumbing", "hvac", "appliance", "structural", "other"
  description     String
  priority        MaintenancePriority @default(NORMAL)
  status          MaintenanceStatus @default(OPEN)
  assignedToId    String?  // Technician user ID
  estimatedCostCents Int?
  actualCostCents Int?
  estimatedDays   Int?
  startedAt       DateTime?
  completedAt     DateTime?
  verifiedAt      DateTime?
  verifiedById    String?  // Manager who verified
  notes           String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  logs            MaintenanceLog[]

  @@index([unitId])
  @@index([status])
  @@index([assignedToId])
  @@index([priority])
  @@index([createdAt])
  @@map("maintenance_requests")
}

/// Maintenance log: work log, parts used, notes
model MaintenanceLog {
  id              String   @id @default(cuid())
  requestId       String
  request         MaintenanceRequest @relation(fields: [requestId], references: [id], onDelete: Cascade)
  loggedById      String   // Technician user ID
  status          MaintenanceStatus // Current status at time of log
  workDescription String   // What was done
  partsUsed       String?  // JSON or text: { "part": "qty" }
  laborHoursCents Int?     // Labor cost in cents
  costCents       Int?     // Parts + labor cost
  notes           String?
  loggedAt        DateTime @default(now())

  @@index([requestId])
  @@map("maintenance_logs")
}

/// Unit status history (audit trail)
model UnitStatusHistory {
  id              String   @id @default(cuid())
  unitId          String
  unit            Unit     @relation(fields: [unitId], references: [id], onDelete: Cascade)
  previousStatus  UnitStatus
  newStatus       UnitStatus
  reason          String?  // e.g., "Checkout", "Cleaning assigned", "Maintenance started"
  changedBy       String?  // User ID
  changedAt       DateTime @default(now())

  @@index([unitId, changedAt])
  @@map("unit_status_history")
}

